# 오늘 할 일

- [x] 자바스크립트 공부
- [x] 리액트 공부

---

# 오늘 한 일 (회고)

- 자바스크립트의 이벤트 루프에 대해서 지금까지 모호하게 알고 있었는데, 개념을 확실히 알 수 있게 된 것 같다.
  - 동기 코드를 실행할 때는 이벤트 루프에 대해서 신경쓰지 않아도 되지만, 비동기 코드를 실행할 때 콜스택에서 Web API로 이동하고, Web API에서 해당 비동기 작업이 완료되면(응답을 받거나 setTimeout의 시간이 모두 경과됐다면) 콜백 큐로 이동한다. 콜백 큐는 microtask queue와 macrotask queue로 나뉘는데, setTimeout과 setInterval같은 함수들은 macrotask queue로, Promise 요청과 같은 함수들은 microtask queue에 담긴다. 그리고, 이벤트 루프는 콜스택이 비었을 때 콜백 큐를 확인해서 microtask queue에 있는 작업을 콜스택으로 가져오고, 이후 microtask queue와 콜 스택이 비게 되면 macrotask queue에 있는 작업을 콜스택으로 가져와 수행한다.
  - 자바스크립트는 확실히 깊게 공부할수록 재미있는 것 같다. 모르는게 생기고, 그 모르는 것에 대한 지식을 채우는 재미와 뿌듯함이 확실해서 좋다.
- 리액트에서 컴포넌트 최적화를 담당하는 useCallback, useMemo, React.memo에 대한 내용을 공부했다.
  - 리액트는 얕은 비교를 통해 state나 props를 비교한다. 그리고 상태가 변경되었다면 새로운 함수, 값, 컴포넌트 등을 리렌더링하게 되는데 useCallback은 의존성 배열에 포함된 값이 변경되지 않는다면 리렌더링 될 때 인자로 들어온, 새롭게 생성된 함수를 무시하고 기존 함수를 반환한다.
  - useMemo는 useCallback과 유사하고, 값을 새롭게 렌더링하는 것을 방지해주는 것이다. 마찬가지로 의존성 배열에 포함된 값이 변경되었을 때에만 기존 값을 다시 계산하고, 변경되지 않는다면 값을 다시 계산하지 않는다. 이것은 렌더링 시의 고비용 계산을 방지하게 해주어 최적화에 도움을 준다.
  - React.memo는 클래스형 컴포넌트에서의 PureComponent와 비슷한 역할을 한다. 즉, 얕은 비교를 통해 동일한 참조 값의 props가 들어온다면 리렌더링을 방지한다. 하지만, React.memo는 props의 변화만 감지하므로 React.memo로 감싸진 컴포넌트에서 useState, useReducer 혹은 useContext 훅을 사용한다면 state나 context가 변할 때 결국 리렌더링된다.

---

# 내일 할 일

- [ ] 자바스크립트 공부
- [ ] 리액트 공부
