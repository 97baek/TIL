# 오늘 할 일

- [x] 자바스크립트 공부
- [x] 리액트 공부

---

# 오늘 한 일 (회고)

- 어렴풋이 알고 있던 CORS와 관련한 개념을 알게 되었다.

  - **SOP**라는 정책에 의해 origin이 다른 사이트들끼리는 리소스에 접근할 수 없는데, **CORS**는 이것을 가능하게 하는 스펙이다. 웹은 기본적으로 다른 출처의 리소스를 요청할 때 HTTP 프로토콜을 사용하는데, 이 때 브라우저가 요청 헤더의 Origin 필드에 요청을 보내는 출처를 담아 전송하면 서버가 응답 헤더의 `Access-Control-Allow-Origin`이라는 값에 '이 리소스를 접근하는 것이 허용된 출처'를 보내준다. 이후 응답을 받은 브라우저는, 자신이 보냈던 요청의 Origin과 서버가 보내준 응답의 `Access-Control-Allow-Origin`을 비교한 후 이 응답이 유효한지 아닌지를 결정하게 된다.

- 자바스크립트의 this는 정말 까다로운 녀석인 것 같다. 이해했다 싶으면 새로운 쓰임이 등장하고, 배우면 배울수록 헷갈리는 녀석이다.

- 리액트 `hooks`의 흐름에 대해서 개념을 새롭게 정립했다. `useEffect`가 클래스형 컴포넌트의 생명주기에서`componentDidMount`, `componentDidUpdate`에 해당된다는 것은 알고는 있었지만, 자식 컴포넌트의 `useEffect`와의 실행 순서가 헷갈리는 부분이 있었는데 그 부분에 대해서 다시 한번 정리하게 된 것 같아 좋은 것 같다.
  - 함수형 컴포넌트에서, 렌더링이 종료되면 `useEffect`가 순서대로 실행된다. 이 때 자식 컴포넌트가 렌더링되면 자식 컴포넌트를 렌더링하고, 자식 컴포넌트의 `useEffect`가 호출된 이후 부모 컴포넌트의 `useEffect`가 다시 호출된다.(의존성 배열이 비어있지 않은 경우)
  - `useEffect`의 의존성 배열에 있는 값에 변경이 생겨 `update`가 일어나면, `cleanup`은 리렌더링이 이후 새로운 `useEffect`를 호출하기 전에 일어난다.(**첫 번째 호출이 아닌 경우**)
  - 위의 동작을 순서로 나타내보면 다음과 같다.
    1. 처음 렌더링이 된 후 `useEffect` 실행
    2. `update` 시, 부모의 `cleanup`이 이루어짐
    3. 자식의 `cleanup`이 이루어짐
    4. 자식의 `useEffect` 실행
    5. 부모의 `useEffect` 실행
  - 이것은 리액트의 불변성과도 연관이 있는데, 원래 있던 것을 아예 지우고 새롭게 갈아끼운다는 느낌으로 생각하면 될 것 같다. 이 개념을 정확히 모른다면 `useEffect`의 호출 시점을 잘못 인지하고 원하는 동작을 원하는 타이밍에 하지 못할 가능성이 높다. 지금까지 정확한 개념없이 경험으로 체득한 내용인데 개념을 잡게되니 좋은 것 같다.

---

# 내일 할 일

- [ ] 자바스크립트 공부
- [ ] 리액트 공부
